# Produce summary figures of the posterior intensity field

library(INLA)
library(inlabru)
library(ggplot2)
library(scales)
library(cowplot)
library(sf)
library(dplyr)
library(magrittr)
library(tidyr)

set.seed(9701071)

# statsoc doc class textwidth in cm
tw <- 14.69785
twi <- 5.7865551181 # pdf() needs inches

# axis title text size
ax.size <- 12

#### Fitted model  ####
model_path <- here::here(
  "R",
  "fitted_models",
  "fitted_model.RDS"
)
fit <- readRDS(model_path)

#### Other things ####
data_path <- here::here("R", "data")
study_area <- readRDS(here::here(data_path, "study_area.RDS"))
samplers <- readRDS(here::here(data_path, "samplers.RDS"))
mesh <- readRDS(here::here(data_path, "mesh.RDS"))

#### Where to save figures ####
fig_path <- here::here("figures")

#### ggplot theme ####
theme_set(theme_minimal())
# theme_set(theme_classic())

#### Specify detection functions  ####

# Log half-normal
log_hn <- function(distance, lsig) {
  -0.5 * (distance / exp(lsig))^2
}

# Half-normal
hn <- function(distance, lsig) exp(log_hn(distance, lsig))

# Include r for switching to polar coords
dsamp <- function(distance, lsig) {
  log(distance) + log_hn(distance, lsig)
}


#### Posterior half-normal plot ####

W <- 58 / 1000
Wm <- 58 # transect radius in metres
distdf <- data.frame(distance = seq(.Machine$double.eps, Wm, length = 100))

# adjust for change of units (km in model fit, metres here)
hnpred <- predict(fit, distdf, ~ hn(distance, lsig + log(1000)),
                  n.samples = 100
)

ghn <- ggplot() +
  gg(hnpred) +
  ylim(c(0, 1)) +
  ylab("detection probability\n") +
  xlab("\ndistance (m)") +
  theme(
    axis.title = element_text(size = ax.size),
    axis.text = element_text(size = ax.size)
  )
ghn

#### Posterior Matern plot ####
blah <- spde.posterior(fit, "grf", what = "matern.correlation")
gmat <- ggplot() +
  gg(blah) +
  ylab("correlation\n") +
  xlab("\ndistance (km)") +
  theme(
    axis.title = element_text(size = ax.size, vjust = 0.3),
    axis.text = element_text(size = ax.size)
  )

gmat

#### Pairwise distances plot ####
# polygon samplers
samplers$ID <- 1:nrow(samplers)
W <- 58 / 1000
samplers_buffered <- st_buffer(samplers, dist = W)

### Generate posterior point patterns
n.pp <- 500

# create distance bins and matrix to store counts
breaks <- 0:12
counts <- matrix(NA, nrow = n.pp, ncol = length(breaks) - 1)

# detection functions
# Log half-normal
log_hn <- function(distance, lsig) {
  -0.5 * (distance / exp(lsig))^2
}

# Half-normal
hn <- function(distance, lsig) exp(log_hn(distance, lsig))

# Need to create a new mesh just in the study area and
# project llam to this. Boundary was giving very large intensities
# when trying with full mesh and samplers argument

## Generated by meshbuilder()

## Build boundary information:
## (fmesher supports SpatialPolygons, but this app is not (yet) intelligent enough for that.)
boundary <- list(
  fm_as_segm(study_area),
  NULL
)

## Build the mesh:
inner_mesh <- fm_mesh_2d_inla(
  loc = fm_hexagon_lattice(study_area, edge_len = 0.15),
  boundary = study_area,
  max.edge = 0.25,
  min.angle = 30,
  max.n = 48000, ## Safeguard against large meshes.
  max.n.strict = 128000, ## Don't build a huge mesh!
  cutoff = 0.024, ## Filter away adjacent points.
  offset = 0.1
) ## Offset for extra boundaries, if needed.

# simulate intensities and detection functions
# each column of llam is a realisation of the log-intensity at each
# inner_mesh node
post.sample <- generate(
  fit,
  st_sf(geometry = fm_as_sfc(inner_mesh, format = "loc")),
  formula = ~ {
    c(llam = grf + Intercept, lsig = lsig_latent)
  },
  n.samples = n.pp
)

inner_llam <- post.sample[seq_len(NROW(inner_mesh$loc)), ]
lsig.post <- post.sample["lsig", ]

library(progressr)
if (interactive()) {
  # Up to user to setup multisession beforehand
  prog <- with_progress
  handlers(handler_progress(
    format = "Computing simulations: [:bar] :percent eta: :eta"
  ))
} else {
  future::plan(future::multisession)
  prog <- without_progress
}

sims_idx <- seq_len(n.pp)
sims_result <- prog({
  prog_bar <- progressor(along = sims_idx)
  future.apply::future_lapply(
    X = sims_idx,
    prog_bar = prog_bar,
    future.seed = 1037584L,
    FUN = function(i, prog_bar) {
      prog_bar()
      #  cat("\nGenerating point pattern ", i, "\n")
      a.pp <- sample.lgcp(
        mesh = inner_mesh,
        loglambda = inner_llam[, i],
        samplers = study_area
      )
      a.pp <- st_as_sf(a.pp)
      # keep only detectable points
      a.pp <- a.pp[a.pp %>%
                     st_within(samplers_buffered) %>%
                     lengths() > 0, ]
      a.lsig <- lsig.post[i]

      #  cat("\nThinning point pattern ", i, "\n")

      # add transect ID for each point
      pp_det <- st_join(
        a.pp,
        samplers_buffered[, "ID"]
      )

      distances <- rep(NA, nrow(pp_det))

      for (j in 1:nrow(pp_det)) {
        pt <- pp_det[j, ]
        transect <- subset(samplers, ID == pt$ID)
        distances[j] <- as.numeric(st_distance(pt, transect))
      }

      pdet <- hn(distances, a.lsig)
      pp_det$distances <- distances
      pp_det$pdet <- pdet

      detected <- rbinom(nrow(pp_det), 1, pdet)
      a.obs <- subset(pp_det, as.logical(detected))

      # calculate pairwise distances
      a.ds <- st_distance(a.obs, byid = TRUE)
      a.ds[upper.tri(a.ds, diag = TRUE)] <- NA
      a.ds.vec <- as.numeric(a.ds)
      a.ds.vec <- a.ds.vec[!is.na(a.ds.vec)]

      counts <- hist(a.ds.vec, breaks = breaks, plot = FALSE)$counts

      #  cat("\nFinished processing point pattern ", i, "\n")

      # memory leak?
      # rm(a.ds, a.ds.vec, a.obs, a.lsig, a.pp)
      # gc()

      counts
    }
  )
})

counts <- do.call(rbind, sims_result)

# pairwise distances for observed data
obs <- readRDS(here::here(data_path, "obs.RDS"))
obs.ds <- st_distance(obs)
obs.ds[upper.tri(obs.ds, diag = TRUE)] <- NA
obs.ds.vec <- as.numeric(obs.ds)
count.obs <- hist(obs.ds.vec, breaks = breaks, plot = FALSE)$counts

# Prepare the counts data for ggplot
counts_df <- as.data.frame(counts)
counts_long <- counts_df %>%
  pivot_longer(cols = everything(), names_to = "distance_bin", values_to = "count") %>%
  mutate(distance_bin = as.numeric(gsub("V", "", distance_bin)))

# Prepare observed data as a separate data frame
count_obs_df <- data.frame(
  distance_bin = seq_len(length(breaks) - 1),
  count = count.obs
)

# Define x-axis tick labels
xticks <- breaks[-1]

gpp <- ggplot() +
  geom_boxplot(
    data = counts_long, aes(x = factor(distance_bin), y = count),
    fill = "white", outlier.shape = NA
  ) +
  geom_point(
    data = count_obs_df, aes(x = distance_bin, y = count),
    color = "red", size = 2
  ) +
  scale_x_discrete(labels = xticks) +
  labs(x = "distance (km)", y = "count of pairwise distances") +
  theme_minimal()
gpp

# Plot with ggplot2
library(patchwork)
pdf(
  file = here::here("figures", "dist_mat_pairs.pdf"),
  width = twi, height = twi
)

(ghn + gmat) / gpp + plot_annotation(tag_levels = "A")

dev.off()
