# Summarise posterior sampled point patterns
# using pairwise distances

library(INLA)
library(inlabru)
library(ggplot2)
library(sf)

# statsoc doc class textwidth in cm
tw = 14.69785
twi = 5.7865551181  # pdf() needs inches

# set ggplot theme
theme_set(theme_minimal())
set.seed(9701071)

#### Fitted model  ####
model_path = here::here("R",
                        "fitted_models",
                        "fitted_model.RDS")
fit = readRDS(model_path)

data_path = here::here("R", "data")
obs <- readRDS(here::here(data_path, "obs.RDS"))
study_area = readRDS(here::here(data_path, "study_area.RDS"))
samplers = readRDS(here::here(data_path, "samplers.RDS"))
mesh = readRDS(here::here(data_path, "mesh.RDS"))

# polygon samplers
samplers$ID = 1:nrow(samplers)
W = 58/1000
samplers_buffered = st_buffer(samplers, dist = W)

### Generate posterior point patterns
n.pp = 500

# simulate intensities and detection functions
# each column of llam is a realisation of the log-intensity at each mesh node
post.sample = generate(fit,
                formula = ~ {c(
                  llam = grf_latent + Intercept_latent,
                  lsig = lsig_latent)
                },
                n.samples = n.pp)

llam = post.sample[1:mesh$n, ]
lsig.post = post.sample["lsig",]

# create distance bins and matrix to store counts
breaks = 0:12
counts = matrix(NA, nrow = n.pp, ncol = length(breaks)-1)

# detection functions
# Log half-normal
log_hn = function(distance, lsig){
  -0.5*(distance/exp(lsig))^2
}

# Half-normal
hn <- function(distance, lsig) exp(log_hn(distance, lsig))

# Need to create a new mesh just in the study area and
# project llam to this. Boundary was giving very large intensities
# when trying with full mesh and samplers argument

## Generated by meshbuilder()

## Build boundary information:
## (fmesher supports SpatialPolygons, but this app is not (yet) intelligent enough for that.)
boundary <- list(
  fm_as_segm(study_area),
  NULL)

## Build the mesh:
inner_mesh <- fm_mesh_2d_inla(boundary=boundary,
                              max.edge=c(0.25, 0.61),
                              min.angle=c(30, 21),
                              max.n=c(48000, 16000), ## Safeguard against large meshes.
                              max.n.strict=c(128000, 128000), ## Don't build a huge mesh!
                              cutoff=0.024, ## Filter away adjacent points.
                              offset=c(0.1, 0.13)) ## Offset for extra boundaries, if needed.

A = inla.spde.make.A(mesh = mesh,
                     loc = inner_mesh$loc)

inner_llam = A %*% llam

# Note:  I think there is a way to use inner_mesh in the generate()
# call above to avoid having to create A and project afterwards.
# Have not tested this though.

for (i in 1:n.pp){

  cat("\nGenerating point pattern ", i, "\n")
  a.pp = sample.lgcp(mesh = inner_mesh,
                     loglambda = inner_llam[,i],
                     samplers = study_area)
  a.pp = st_as_sf(a.pp)
  # keep only detectable points
  a.pp = a.pp[a.pp %>% st_within(samplers_buffered) %>% lengths > 0, ]
  a.lsig = lsig.post[i]

  cat("\nThinning point pattern ", i, "\n")

  # add transect ID for each point
  pp_det = st_join(a.pp,
                   samplers_buffered[,"ID"])

  distances = rep(NA, nrow(pp_det))

  for (j in 1:nrow(pp_det)){
    pt = pp_det[j,]
    transect = subset(samplers, ID == pt$ID)
    distances[j] = as.numeric(st_distance(pt, transect))
  }

  pdet = hn(distances, a.lsig)
  pp_det$distances = distances
  pp_det$pdet = pdet

  detected <- rbinom(nrow(pp_det), 1, pdet)
  a.obs <- subset(pp_det, as.logical(detected))

  # calculate pairwise distances
  a.ds = st_distance(a.obs, byid = TRUE)
  a.ds[upper.tri(a.ds, diag = TRUE)] = NA
  a.ds.vec = as.numeric(a.ds)
  a.ds.vec = a.ds.vec[!is.na(a.ds.vec)]
  counts[i,] = hist(a.ds.vec, breaks = breaks, plot = FALSE)$counts

  cat("\nFinished processing point pattern ", i, "\n")

  # memory leak?
  # rm(a.ds, a.ds.vec, a.obs, a.lsig, a.pp)
  # gc()
}

# pairwise distances for observed data
obs.ds = st_distance(obs)
obs.ds[upper.tri(obs.ds, diag = TRUE)] = NA
obs.ds.vec = as.numeric(obs.ds)
count.obs = hist(obs.ds.vec, breaks = breaks, plot = FALSE)$counts

# plot
pdf(file = here::here("figures", "post_pp_distances.pdf"),
    width = twi, height = twi/2)

boxplot(counts,
        xlab = "distance (km)",
        ylab = "count of pairwise distances",
        xaxt = "n",
        range = 0,
        col = "white")
points(1:(length(breaks)-1), count.obs, col = "red")
# xticks = floor(breaks[-1] - (breaks[2] - breaks[1])/2)
xticks = breaks[-1]
axis(1, at = 1:(length(breaks)-1), labels = xticks)

dev.off()
