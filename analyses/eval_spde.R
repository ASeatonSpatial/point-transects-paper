 # Evaluate spde by posterior sampling

library(INLA)
library(inlabru)
library(rgeos)
source("helper_functions.R")

# set ggplot theme
theme_set(theme_minimal())
set.seed(9701071)

#### WARNING - as it stands this script will overwrite figures for the paper

#### Fitted model  ####
model_path = here::here("analyses", "akepa_2002_fitted_model_new_inlabru.RDS")
fit = readRDS(model_path)

data_path = here::here("analyses", "data")
obs <- readRDS(here::here(data_path, "obs_extended_no_crs.RDS"))
study_area = readRDS(here::here(data_path, "study_area_extended_no_crs.RDS"))
samplers = readRDS(here::here(data_path, "samplers_extended_no_crs.RDS"))
W = 58/1000
samplers_buffered = gBuffer(samplers, width = W, byid = TRUE)
mesh = readRDS(here::here(data_path, "mesh_extended_no_crs.RDS"))

### Generate posterior point patterns
n.pp = 100

# simulate intensities and detection functions
# each column of llam is a realisation of the log-intensity at each mesh node
post.sample = generate(fit,
                formula = ~ {c(
                  llam = grf_latent + Intercept_latent,
                  lsig = lsig_latent)
                },
                n.samples = n.pp)

llam = post.sample[1:mesh$n, ]
lsig.post = post.sample["lsig",]

# create bins and matrix to store counts
# max.ds = max(as.numeric(gDistance(samplers, byid = TRUE)))
# breaks = seq(0, ceiling(max.ds), by = round(ceiling(max.ds)) / 15)
breaks = 0:12

# plot one point pattern
# a.pp = subset(post.pp, sample == 1)
# ggplot() +
#   gg(study_area) +
#   gg(a.pp) +
#   coord_equal()

# detection functions
# Log half-normal
log_hn = function(distance, lsig){
  -0.5*(distance/exp(lsig))^2
}

# Half-normal
hn <- function(distance, lsig) exp(log_hn(distance, lsig))

# thin.pp needs a plotID columns
samplers$plotID = samplers$SampleLabel
samplers_buffered$plotID = samplers$plotID
counts = matrix(NA, nrow = n.pp, ncol = length(breaks)-1)

# Need to create a new mesh just in the study area and
# project llam to this.  Boundary was giving me very large intensities
# when trying with full mesh and samplers argument

## Generated by meshbuilder()

## Build boundary information:
## (fmesher supports SpatialPolygons, but this app is not (yet) intelligent enough for that.)
boundary <- list(
  as.inla.mesh.segment(study_area),
  NULL)

## Build the mesh:
inner_mesh <- inla.mesh.2d(boundary=boundary,
                     max.edge=c(0.25, 0.61),
                     min.angle=c(30, 21),
                     max.n=c(48000, 16000), ## Safeguard against large meshes.
                     max.n.strict=c(128000, 128000), ## Don't build a huge mesh!
                     cutoff=0.024, ## Filter away adjacent points.
                     offset=c(0.1, 0.13)) ## Offset for extra boundaries, if needed.

A = inla.spde.make.A(mesh = mesh,
                     loc = inner_mesh$loc)

inner_llam = A %*% llam

# Getting memory leak in the loops, suspect the rgeos function
# and can't seem to find out a way to make sure everything is deleted
# each loop.

# Use sf functions to avoid rgeos
samplers_sf = st_as_sf(samplers)
samplers_buffered_sf = st_buffer(samplers_sf,
                                 dist = W)

for (i in 1:n.pp){

  cat("\nGenerating point pattern ", i, "\n")
  a.pp = sample.lgcp(mesh = inner_mesh,
                     loglambda = inner_llam[,i],
                     samplers = study_area)
  a.pp = a.pp[samplers_buffered,]   # detectable points
  a.lsig = lsig.post[i]

  cat("\nThinning point pattern ", i, "\n")
  a.pp = st_as_sf(a.pp)
  pp_det = st_join(a.pp,
                   samplers_buffered_sf[,"plotID"])

  distances = rep(NA, nrow(pp_det))

  for (j in 1:nrow(pp_det)) {
    pt = pp_det[j,]
    transect = subset(samplers_sf, plotID == pt$plotID)
    distances[j] = as.numeric(st_distance(pt, transect))
  }

  pdet = hn(distances, a.lsig)
  pp_det$distances = distances
  pp_det$pdet = pdet

  detected <- rbinom(nrow(pp_det), 1, pdet)
  a.obs <- subset(pp_det, as.logical(detected))

  a.ds = st_distance(a.obs, byid = TRUE)
  a.ds[upper.tri(a.ds, diag = TRUE)] = NA
  a.ds.vec = as.numeric(a.ds)
  a.ds.vec = a.ds.vec[!is.na(a.ds.vec)]
  counts[i,] = hist(a.ds.vec, breaks = breaks, plot = FALSE)$counts

  cat("\nFinished processing point pattern ", i, "\n")

  # memory?
  rm(a.ds, a.ds.vec, a.obs, a.lsig, a.pp)
  gc()
}

# freq for observations
obs.ds = gDistance(obs, byid = TRUE)
obs.ds[upper.tri(obs.ds, diag = TRUE)] = NA
obs.ds.vec = as.numeric(obs.ds)
count.obs = hist(obs.ds.vec, breaks = breaks, plot = FALSE)$counts

# plot
png(filename = "../figures/post_pp_distances.png",
    width = 7, height = 4, units = "in", res = 100)

boxplot(counts,
        xlab = "distance (km)",
        ylab = "count of pairwise distances",
        xaxt = "n",
        range = 0,
        col = "white")
points(1:(length(breaks)-1), count.obs, col = "red")
# xticks = floor(breaks[-1] - (breaks[2] - breaks[1])/2)
xticks = breaks[-1]
axis(1, at = 1:(length(breaks)-1), labels = xticks)
dev.off()
